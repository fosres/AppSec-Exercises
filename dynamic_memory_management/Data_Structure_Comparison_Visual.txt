╔═══════════════════════════════════════════════════════════════════════════════════════════╗
║                    MEMORY TRACKING DATA STRUCTURE COMPARISON                              ║
║                        For Leak Detection with Boundary Tags                              ║
╚═══════════════════════════════════════════════════════════════════════════════════════════╝

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ TIME COMPLEXITY                                                                           │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Operation           │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Insert (malloc)     │ O(log n)     │ O(log n)*    │ O(1) ✓              │ O(1) ✓         │
│ Delete (free)       │ O(log n)     │ O(log n)*    │ O(1) ✓              │ O(1) ✓         │
│ Search by pointer   │ O(log n)     │ O(log n)*    │ N/A †               │ O(1) ✓         │
│ Exit traversal      │ O(n)         │ O(n)         │ O(n)                │ O(n)           │
├─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┤
│ * Expected case, worst case O(n)                                                         │
│ † Not needed with boundary tags - calculate node location directly                       │
└───────────────────────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ MEMORY OVERHEAD                                                                           │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Metric              │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Fixed overhead      │ ~16 bytes    │ ~16 bytes    │ ~32 bytes ✓         │ ~80 KB ✗       │
│ Per-allocation      │ 48-56 bytes  │ 40-60 bytes  │ 48 bytes ✓          │ 48 bytes       │
│ Malloc calls/alloc  │ 2 mallocs    │ 2 mallocs    │ 1 malloc ✓          │ 2 mallocs      │
│                     │              │              │                     │                │
│ Total (100 allocs)  │ 4.7 KB       │ 4.9 KB       │ 4.7 KB ✓            │ 82.9 KB ✗      │
│ Total (1K allocs)   │ 46.9 KB      │ 48.8 KB      │ 46.9 KB ✓           │ 125 KB ✗       │
│ Total (10K allocs)  │ 469 KB       │ 488 KB       │ 469 KB ✓            │ 549 KB         │
│                     │              │              │                     │                │
│ Memory multiplier   │ 1x           │ 1.04x        │ 1x ✓                │ 1.17x - 17.6x  │
│ vs intrusive list   │              │              │                     │                │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ IMPLEMENTATION COMPLEXITY                                                                 │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Metric              │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Lines of code       │ ~400-500     │ ~250-350     │ ~100-150 ✓          │ ~150-200       │
│ Difficulty          │ Very High    │ Medium       │ Very Low ✓          │ Low            │
│ Rotation logic      │ 4 cases      │ None         │ None ✓              │ None           │
│ Balance tracking    │ Required     │ Probabilistic│ None ✓              │ None           │
│ Edge cases          │ Many         │ Some         │ Minimal ✓           │ Few            │
│ Debug difficulty    │ Very High    │ Medium       │ Very Low ✓          │ Low            │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ PERFORMANCE CHARACTERISTICS                                                               │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Metric              │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Worst-case insert   │ O(log n)     │ O(n)         │ O(1) ✓              │ O(n)           │
│ Cache locality      │ Poor         │ Very Poor    │ Good ✓              │ Poor           │
│ Predictability      │ High         │ Low          │ Very High ✓         │ Medium         │
│ Deterministic?      │ Yes          │ No           │ Yes ✓               │ Mostly         │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ CERT C & SAFETY-CRITICAL COMPLIANCE                                                       │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Metric              │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Pointer arithmetic  │ Standard     │ Standard     │ offsetof() ✓        │ Standard       │
│ Alignment handling  │ None         │ None         │ alignas() required  │ None           │
│ Audit difficulty    │ High         │ Medium       │ Low ✓               │ Low            │
│ MISRA C friendly    │ Medium       │ Medium       │ High ✓              │ High           │
│ Code complexity     │ Very High    │ Medium       │ Very Low ✓          │ Low            │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┘

┌───────────────────────────────────────────────────────────────────────────────────────────┐
│ SUITABILITY SCORES (1-10, higher is better)                                               │
├─────────────────────┬──────────────┬──────────────┬─────────────────────┬────────────────┤
│ Criterion           │ AVL Tree     │ Skip List    │ Intrusive List      │ Hash Table     │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ Speed               │ 7/10         │ 7/10         │ 10/10 ✓             │ 10/10 ✓        │
│ Memory efficiency   │ 8/10         │ 7/10         │ 10/10 ✓             │ 3/10           │
│ Simplicity          │ 2/10         │ 5/10         │ 10/10 ✓             │ 7/10           │
│ CERT C compliance   │ 8/10         │ 8/10         │ 9/10 ✓              │ 9/10           │
│ Maintainability     │ 3/10         │ 6/10         │ 10/10 ✓             │ 8/10           │
│ Debuggability       │ 3/10         │ 6/10         │ 10/10 ✓             │ 8/10           │
├─────────────────────┼──────────────┼──────────────┼─────────────────────┼────────────────┤
│ OVERALL SCORE       │ 31/60        │ 39/60        │ 59/60 ✓             │ 45/60          │
└─────────────────────┴──────────────┴──────────────┴─────────────────────┴────────────────┘

╔═══════════════════════════════════════════════════════════════════════════════════════════╗
║                                  RECOMMENDATION                                           ║
╠═══════════════════════════════════════════════════════════════════════════════════════════╣
║                                                                                           ║
║  FOR LEAK DETECTION WITH BOUNDARY TAGS (Your Use Case):                                  ║
║                                                                                           ║
║  ┌─────────────────────────────────────────────────────────────────────────────────────┐ ║
║  │  ★ INTRUSIVE DOUBLY LINKED LIST - CLEAR WINNER ★                                   │ ║
║  └─────────────────────────────────────────────────────────────────────────────────────┘ ║
║                                                                                           ║
║  Advantages:                                                                              ║
║    ✓ O(1) insert and delete (fastest possible)                                           ║
║    ✓ 3-18x less memory overhead than alternatives                                        ║
║    ✓ Simplest implementation (~100 lines vs 250-500)                                     ║
║    ✓ CERT C compliant with offsetof() + alignas()                                        ║
║    ✓ Easiest to audit for safety-critical work                                           ║
║    ✓ Deterministic, predictable behavior                                                 ║
║    ✓ Best cache locality at program exit                                                 ║
║    ✓ 50% fewer malloc calls = less fragmentation                                         ║
║                                                                                           ║
║  Use alternatives ONLY if:                                                                ║
║    • Can't modify malloc() return value        → Hash Table                              ║
║    • Need ordered traversal                    → Skip List or AVL Tree                   ║
║    • Building lock-free concurrent system      → Skip List                               ║
║                                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════════════════════╝

KEY INSIGHTS FOR YOUR THESIS:

1. Boundary Tags Change Everything
   - Without boundary tags: need O(log n) search → Skip List or Hash Table competitive
   - With boundary tags: O(1) node recovery → Intrusive List dominates

2. Memory Matters More Than You Think
   - Hash table's 80KB fixed overhead is 17x worse for small allocation counts
   - Extra malloc calls cause fragmentation (AVL/Skip/Hash need 2x, intrusive needs 1x)

3. Simplicity is a Feature
   - In safety-critical code (automotive, medical, aerospace)
   - Simpler code = easier audits = higher confidence
   - ~100 lines vs ~400 lines is massive difference

4. For Your Career Goals (Safety-Critical Industries)
   - Demonstrating you chose simplest solution shows maturity
   - Understanding CERT C compliance (alignas, offsetof) shows expertise
   - Measuring actual memory overhead shows engineering rigor
   - This is exactly what $120K-200K+ jobs look for

═══════════════════════════════════════════════════════════════════════════════════════════

REFERENCES:
- SEI CERT C Coding Standard 2016 - Rules EXP36-C, MEM36-C
- "Effective C, 2nd Edition" by Robert Seacord - Chapter 6 (Memory Management)
- "The Art of Software Security Assessment" - Allocator patterns, boundary tags
- Donald Knuth, "The Art of Computer Programming, Vol 1" - Boundary tag algorithm
- Compiled test results from working implementations in this project
